<html>
<head>
<title>Brian W. Kernighan: Programming in C: A Tutorial</title>
<link rel="made" rev="made" href="mailto:jutta@pobox.com">
</head>
<body>
<center>
<h1>
<a name="bwk">Programming</a> in C:&#160;<tt> </tt>A Tutorial
</h1>
<h2> 
			<a href="bwk/index.html">Brian W. Kernighan</a><br>
		Bell Laboratories, Murray Hill, N. J.
</h2>
</center>
<hr>
<b>Disclaimer:</b>  This ``tutorial'' is presented as a historical document,
not as a tutorial.&#160;<tt> </tt>Although it has lost little of its didactic
value, it describes a language that C compilers today do no longer understand:
the C of 1974, four years before <a href="bwk/index.html">Kernighan</a>
and <a href="http://www.cs.bell-labs.com/who/dmr/index.html" name="dmr">Ritchie</a> published the first edition
of ``The C Programming Language''.
<hr>
<p>
Table of Contents:
<ol>
<li> <a href="#introduction">Introduction</a>
<li> <a href="#simple-c">A Simple C Program</a>
<li> <a href="#working-c">A Working C Program;
	Variables; Types and Type Declarations</a>
<li> <a href="#constant">Constants</a>
<li> <a href="#simple-io">Simple I/O</a> -- getchar, putchar, printf
<li> <a href="#if">If</a>;
	<a href="#relational">relational operators</a>;
	<a href="#compound">compound statements</a>
<li> <a href="#while">While Statement</a>;
	<a href="#assignment-within">Assignment within an Expression</a>;
	<a href="#null-statement">Null Statement</a>
<li> <a href="#arithmetic">Arithmetic</a>
<li> <a href="#else">Else Clause</a>;
	<a href="#conditional">Conditional Expressions</a>
<li> <a href="#increment">Increment and Decrement Operators</a>
<li> <a href="#array">Arrays</a>
<li> <a href="#character-array">Character Arrays; Strings</a>
<li> <a href="#for">For Statement</a>
<li> <a href="#functions">Functions; Comments</a>
<li> <a href="#variables">Local and External Variables</a>
<li> <a href="#pointers">Pointers</a>
<li> <a href="#argument">Function Arguments</a>
<li> <a href="#multiple-level">Multiple Levels of Pointers;
		Program Arguments</a>
<li> <a href="#switch">The Switch Statement;
		Break;
		Continue</a>
<li> <a href="#structure">Structures</a>
<li> <a href="#initialization">Initialization</a> of Variables
<li> <a href="#scope">Scope Rules</a>: Who Knows About What
<li> <a href="#define">#define</a>, <a href="#include">#include</a>
<li> <a href="#bit">Bit Operators</a>
<li> <a href="#assignment">Assignment Operators</a>
<li> <a href="#floating">Floating Point</a>
<li> Horrors! <a href="#goto">goto's and labels</a>
<li> <a href="#acknowledgement">Acknowledgements</a>
</ol>
<hr>
<p>
<h2>
  1.&#160;<tt> </tt><a name="introduction">Introduction</a>.
</h2>
       C is a computer language available on the GCOS and UNIX operating
  systems at Murray Hill and (in preliminary form) on OS/360 at
  Holmdel.&#160;<tt> </tt>C  lets  you  write  your  programs  clearly
  and simply it has decent
  control flow facilities so your code can be  read  straight  down  the
  page, without labels or GOTO's; it lets you write code that is compact
  without being too cryptic;  it encourages modularity and good  program
  organization; and it provides good data-structuring facilities.
<p>
       This  memorandum  is a tutorial to make learning C as painless as
  possible.&#160;<tt> </tt>The first part concentrates on the central features 
  of  C; the second part discusses those parts of the language which are
  useful (usually for getting more efficient and smaller code) but which
  are not  necessary  for  the  new user.&#160;<tt> </tt>This is <em>not</em>
  a reference manual.&#160;<tt> </tt>
  Details and special cases will be skipped ruthlessly,  and no  attempt
  will be made to cover every language feature.&#160;<tt> </tt>
  The  order  of presentation is hopefully pedagogical instead of
  logical.&#160;<tt> </tt>Users  who
  would  like  the full story should consult the &quot;C
  Reference Manual&quot; by D. M.  Ritchie <a href="#lit-1" name="source-1">[1]</a>,
  which should be read
  for details anyway.&#160;<tt> </tt>
  Runtime support is described in <a href="#lit-2" name="source-2">[2]</a> and
  <a href="#lit-3" name="source-3">[3]</a>;  you will have to read one of these to
  learn how to compile and run a C program.
<p>
       We will assume that  you  are  familiar  with  the  mysteries  of
  creating files, text editing, and the like in the operating system you
  run on, and that you have programmed in  some language before.
<p>
<p>
<h2>
                          2.&#160;<tt> </tt><a name="simple-c">A Simple C Program</a>
</h2>
<pre>
       main( ) {
               printf(&quot;hello, world&quot;);
       }
</pre>
       A C program consists of one  or   more   functions,   which  are
  similar  to  the functions and subroutines of a Fortran program or the
  procedures of PL/I, and perhaps some external data  definitions.&#160;<tt> </tt>
  <code>main</code>
  is such a function,  and in fact all C programs must have  a
  <code>main</code>.&#160;<tt> </tt>
  Execution  of  the  program begins  at  the  first statement of 
  <code>main</code>.&#160;<tt> </tt>
  <code>main</code>  will  usually  invoke  other functions to perform its job,
  some coming  from the same program, and others from libraries.
<p>
       One method of  communicating  data  between   functions   is  by
  arguments.&#160;<tt> </tt>
  The parentheses following the function name surround the argument
  list; here <code>main</code> is a  function  of  no arguments, indicated
  by  ( ).&#160;<tt> </tt>The {} enclose the statements of the
  function.&#160;<tt> </tt>Individual statements end with a semicolon
  but are otherwise free-format.
<p>
       <code>printf</code> is a library function which will format and  print
  output on the terminal (unless some other destination is specified).&#160;<tt> </tt>
  In this  case it prints
<pre>
       hello, world
</pre>
  A function is invoked by naming it, followed by  a  list  of arguments
  in parentheses.&#160;<tt> </tt>There is no CALL statement as in Fortran or PL/I.
<p>
<p>
<h2>
      3.&#160;<tt> </tt>A <a name="working-c">Working C Program</a>; Variables; Types and Type Declarations
</h2>
       <a name="onetwothree">Here's  a  bigger  program</a>
       that adds  three  integers  and prints their sum.
<pre>
       main( ) {
               int a, b, c, sum;
               a = 1;  b = 2;  c = 3;
               sum = a + b + c;
               printf(&quot;sum is %d&quot;, sum);
       }
</pre>
       Arithmetic and the assignment statements are  much  the  same  as
  in  Fortran  (except  for  the  semicolons) or PL/I.&#160;<tt> </tt>The format of C
  programs is quite  free.&#160;<tt> </tt>We  can  put  several statements on a line
  if  we  want,  or  we  can split a statement among several lines if it
  seems desirable.&#160;<tt> </tt>The split may  be between  any  of  the operators or
  variables,  but <em>not</em> in the middle of a name or operator.&#160;<tt> </tt>As
  a matter of style, spaces, tabs, and newlines should  be  used  freely  to
  enhance readability.
<p>
       C has four fundamental types of variables:
<p>
<ul>
<li> int&#160;<tt> </tt>integer (PDP-11: 16 bits; H6070: 36 bits; IBM360: 32 bits)
<li> char&#160;<tt> </tt>one byte character (PDP-11, IBM360: 8 bits; H6070: 9 bits)
<li> float&#160;<tt> </tt>single-precision floating point
<li> double&#160;<tt> </tt>double-precision floating point
</ul>
<p>
  There are also arrays and structures of these  basic  types,  pointers
  to  them  and  functions  that return them,  all of which we will meet
  shortly.
<p>
       All variables in a C program must be declared, although this  can
  sometimes  be  done implicitly by context.&#160;<tt> </tt>Declarations must
  precede executable statements.&#160;<tt> </tt>The declaration
<pre>
       int a, b, c, sum;
</pre>
  declares <code>a</code>, <code>b</code>, <code>c</code>, and <code>sum</code>
  to be integers.
<p>
       Variable names have one to eight characters, chosen from  A-Z,
  a-z,  0-9, and _,  and start with a non-digit.&#160;<tt> </tt>
  Stylistically, it's much better to use only  a  single  case  and  
  give   functions and   external  variables  names  that  are  unique 
  in  the first six characters.&#160;<tt> </tt>(Function and external
  variable  names  are  used  by various assemblers, some of which are
  limited in the size and case  of identifiers  they  can handle.)
  Furthermore, keywords and library functions may only be recognized
  in one case.
<p>
<h2>
              4.&#160;<tt> </tt><a name="constant">Constants</a>
</h2>
       We  have already seen decimal integer constants  in  the
       <a href="#onetwothree">previous
  example</a>-- 1, 2, and 3.&#160;<tt> </tt>
  Since C is often used for system programming
  and bit-manipulation,  octal  numbers  are an  important  part  of the
  language.&#160;<tt> </tt>In C, any number that begins with 0 (zero!) is an  octal
  integer (and  hence can't have any 8's or 9's in it).&#160;<tt> </tt>
  Thus <code>0777</code> is an octal constant, with decimal value 511.
<p>
       A ``character'' is one  byte  (an  inherently   machine-dependent
  concept).&#160;<tt> </tt>Most often this is expressed as a character constant,
  which is one character  enclosed  in  single quotes.&#160;<tt> </tt>However,
  it  may  be any quantity that fits in a byte, as in flags below:
<pre>
       char quest, newline, flags;
       quest = '?';
       newline = '\n';
       flags = 077;
</pre>
       The sequence `\n'  is  C  notation  for   ``newline  character'',
  which,  when printed,  skips the terminal to the beginning of the next
  line.&#160;<tt> </tt>Notice that `\n' represents only a single character.&#160;<tt> </tt>
There are  several other ``escapes'' like `\n'  for representing hard-to-get
  or invisible characters, such  as  `\t'  for tab,  `\b' for backspace,
  `\0' for end of file, and `\\' for the backslash itself.
<p>
       <code>float</code> and <code>double</code> constants are discussed
       in <a href="#floating">section 26</a>.
<p>
<h2>
   5.&#160;<tt> </tt><a name="simple-io"> Simple I/O</a> -- getchar, putchar, printf
</h2>
<pre>
       main( ) {
               char c;
               c = getchar( );
               putchar(c);
       }
</pre>
<p>
       <code>getchar</code>  and  <code>putchar</code>  are the basic
  I/O library functions in C.  <code>getchar</code> fetches one character
  from the  standard  input  (usually  the
  terminal)  each time it is called,   and  returns that  character  as
  the  value  of  the function.&#160;<tt> </tt>When it reaches the end  of  whatever
  file  it  is   reading,   thereafter  it   returns   the   character
  represented by `\0' (ascii NUL,  which has value zero).&#160;<tt> </tt>We will see
  how  to  use  this  very shortly.
<p>
       <code>putchar</code> puts one character out on the standard output
  (usually
  the terminal) each time it is called.&#160;<tt> </tt>So the program above reads one
  character  and  writes  it  back  out.&#160;<tt> </tt>By itself,   this isn't very
  interesting, but observe that if we put a loop around this,  and add a
  test for end of  file, we have a complete program for copying one file
  to another.
<p>
     <code>printf</code> is a more complicated  function for producing formatted
  output.&#160;<tt> </tt>We will talk about only the simplest use of it.&#160;<tt> </tt>Basically,
  <code>printf</code> uses its first argument as formatting information, and
  any successive arguments as variables to be output.&#160;<tt> </tt>Thus
<pre>
       printf (&quot;hello, world\n&quot;);
</pre>
  is  the  simplest use.&#160;<tt> </tt>The  string  ``hello,   world\n''  is printed
  out.&#160;<tt> </tt>No formatting information, no variables, so the string is dumped
  out  verbatim.&#160;<tt> </tt>The  newline is necessary to put this out on a
  line by itself.&#160;<tt> </tt>(The construction
<pre>
       &quot;hello, world\n&quot;
</pre>
  is really an array of chars.&#160;<tt> </tt><a href="#character-array">More
  about this shortly</a>.)
<p>
       More complicated, if <code>sum</code> is 6,
<pre>
       printf (&quot;sum is %d\n&quot;, sum);
</pre>
  prints
<pre>
       sum is 6
</pre>
  Within the first argument of <code>printf</code>, the  characters
  ``%d''  signify that the next argument in the argument list is to be
  printed as a base 10 number.
<p>
       Other useful formatting commands are  ``%c''  to  print  out   a
  single character,  ``%s''  to  print  out an entire string, and ``%o''
 to print a number  as  octal  instead  of decimal (no leading  zero).&#160;<tt> </tt>
  For example,
<pre>
       n = 511;
       printf (&quot;What is the value of %d in octal?&quot;, n);
       printf (&quot;%s! %d decimal is %o octal\n&quot;, &quot;Right&quot;, n, n);
</pre>
  prints
<pre>
       What is the value of 511 in octal?  Right! 511  decimal
       is 777 octal
</pre>
  Notice that there is no newline at the end of the first output   line.&#160;<tt> </tt>
  Successive  calls  to <code>printf</code> (and/or <code>putchar</code>,
  for that matter) simply
  put out characters.&#160;<tt> </tt>
  No  newlines  are printed unless  you  ask  for
  them.&#160;<tt> </tt>Similarly,  on input, characters are read one at a time as you
  ask  for  them.&#160;<tt> </tt>Each line is generally terminated
  by a newline  (\n), but there is otherwise no concept of record.
<p>
<h2>
             6.&#160;<tt> </tt><a name="if">If</a>;
	relational operators; compound statements
</h2>
       The basic conditional-testing statement in C is the  if
  statement:
<pre>
       c = getchar( );
       if( c == '?' )
               printf(&quot;why did you type a question mark?\n&quot;);
</pre>
  The simplest form of if is
<pre>
       if (<i>expression</i>) <i>statement</i>
</pre>
<p>
       The  condition  to  be  tested  is  any   expression  enclosed in
  parentheses.&#160;<tt> </tt>It is followed  by  a  statement.&#160;<tt> </tt>
  The  expression  is evaluated, and if its value is non-zero, the
  statement  is  executed.&#160;<tt> </tt>
  There's an optional <a href="#else">else clause</a>, to be described soon.
<p>
       The character sequence `=='  is one of 
the  <a name="relational">relational operators</a> in C; here is
the complete set:
<pre>
       ==      <i>equal to (</i>.EQ.<i> to Fortraners)</i>
       !=      <i>not equal to</i>
       &gt;       <i>greater than</i>
       &lt;       <i>less than</i>
       &gt;=      <i>greater than or equal to</i>
       &lt;=      <i>less than or equal to</i>
</pre>
<p>
       The  value  of  ``expression  <i>relation</i>  expression''  is 1 if the
  relation is true, and 0 if false.&#160;<tt> </tt>Don't forget that the equality test
  is `==';  a single `='  causes an assignment, not a test, and
  invariably leads to disaster.
<p>
       Tests can be combined with the operators `&amp;&amp;' (AND),
  `||' (OR), and `!' (NOT).&#160;<tt> </tt>For example, we can
  test whether a character is blank or tab or newline with
<pre>
       if( c==' ' || c=='\t' || c=='\n' ) ...
</pre>
  C  guarantees that `&amp;&amp;' and `||' are evaluated left to right --
  we shall soon see cases where this matters.
<p>
       <a name="compound">One of the nice things about C</a> is  that
  the  statement part of an if can  be  made  arbitrarily complicated
  by enclosing a set of statements in {}.&#160;<tt> </tt>As a simple example,
  suppose we want to ensure that <code>a</code> is bigger than <code>b</code>,
  as part of a sort routine.&#160;<tt> </tt>The interchange of <code>a</code> 
  and <code>b</code> takes three statements in C, grouped together by {}:
<pre>
       if (a &lt; b) {
               t = a;
               a = b;
               b = t;
       }
</pre>
<p>
       As  a  general  rule  in  C,  anywhere  you  can  use   a  simple
  statement, you can use any compound statement,  which is just a number
  of simple or compound ones enclosed in  {}.&#160;<tt> </tt>There is  no  semicolon
  after  the } of a compound statement, but there <em>is</em> a semicolon after
  the last  non-compound statement inside the {}.
<p>
       The  ability to replace  single  statements  by  complex ones  at
  will is one feature that makes  C  much  more  pleasant  to  use  than
  Fortran.&#160;<tt> </tt>Logic  (like  the exchange in the previous  example) which
  would require several GOTO's and labels in Fortran can and  should  be
  done in C  without any, using compound statements.
<p>
<h2>
   7.&#160;<tt> </tt><a name="while">While Statement</a>; Assignment within an Expression; Null Statement
</h2>
       The  basic  looping  mechanism in C is the while  statement.&#160;<tt> </tt>
  Here's a program that copies its input to its output a character at  a
  time.&#160;<tt> </tt>Remember that `\0' marks the end  of file.
<pre>
       main( ) {
               char c;
               while( (c=getchar( )) != '\0' )
                       putchar(c);
       }
</pre>
  The while statement is a loop, whose general form is
<pre>
       while (<i>expression</i>) <i>statement</i>
</pre>
  Its meaning is
<dl><dt><dd>(a)&#160;<tt> </tt>evaluate the expression<br>
    (b)&#160;<tt> </tt>if its value is true (i.e., not zero)
                       do the statement, and go back to (a)
</dl>
  Because the expression is tested  before  the  statement  is executed,
  the statement  part  can  be  executed  zero  times,  which  is  often
  desirable.&#160;<tt> </tt>As  in   the   if   statement,   the  expression
  and the statement can both be arbitrarily complicated,  although we
  haven't seen that yet.&#160;<tt> </tt>Our example gets the  character,
  assigns  it  to c, and then tests if it's a `\0''.&#160;<tt> </tt>If it is
  not a  `\0',  the  statement part of the  <code>while</code> is executed,
  printing the  character.&#160;<tt> </tt>The <code>while</code>  then
  repeats.&#160;<tt> </tt>When the input character is finally a `\0',
  the <code>while</code> terminates, and so does <code>main</code>.
<p>
       <a name="assignment-within">Notice that we used an</a> assignment
       statement
<pre>
       c = getchar( )
</pre>
  within an expression.&#160;<tt> </tt>This is a handy notational shortcut  which
  often  produces  clearer  code.&#160;<tt> </tt>(In fact it is often the only way to
  write the code cleanly.&#160;<tt> </tt>As  an  exercise,  rewrite  the  file-copy
  without using an assignment inside an expression.)&#160;<tt> </tt>It works
  because an assignment statement has  a value,  just as any other
  expression does.  Its value is the value of the right hand side.&#160;<tt> </tt>
  This also implies that we can use multiple assignments like
<pre>
       x = y = z = 0;
</pre>
  Evaluation goes from right to left.
<p>
       By the way, the extra  parentheses  in  the  assignment statement
  within  the conditional were really necessary: if we had said
<pre>
       c = getchar( ) != '\0'
</pre>
  <code>c</code>  would be set to 0 or 1 depending on whether the 
  character fetched
  was an end of file or not.&#160;<tt> </tt>This  is  because  in  the  absence   of
  parentheses  the  assignment  operator  `='  is evaluated  after the
  relational  operator  `!='.&#160;<tt> </tt>When  in  doubt, or even if not,
  parenthesize.
<p>
       <a name="null-statement">Since</a>  <code>putchar(c)</code>
  returns  <code>c</code>
  as its  function  value,   we could also copy the input to the output
  by nesting the calls to <code>getchar</code>  and <code>putchar</code>:
<pre>
   main( ) {
           while( putchar(getchar( )) != '\0' ) ;
   }
</pre>
  What  statement  is being repeated?   None,  or technically,  the null
  statement,   because all the work is really done within the test  part
  of  the  while.&#160;<tt> </tt>This  version  is   slightly   different  from  the
  previous  one,  because the final `\0' is copied to the output  before
  we decide to stop.
<p>
<h2>
                              8.&#160;<tt> </tt><a name="arithmetic">Arithmetic</a>
</h2>
       The arithmetic operators are the usual `+',   `-',  `*', and  `/'
  (truncating  integer  division if the operands are both int),  and the
  remainder or mod operator `%':
<pre>
       x = a%b;
</pre>
  sets x to the remainder after <code>a</code> is divided by <code>b</code>
  (i.e., a mod b).&#160;<tt> </tt>The results  are machine dependent unless
  <code>a</code> and <code>b</code> are both positive.
<p>
       In arithmetic, <code>char</code> variables can  usually  be 
  treated like  <code>int</code>
  variables.&#160;<tt> </tt>Arithmetic   on   characters  is quite legal,
  and often makes sense:
<pre>
       c = c + 'A' - 'a';
</pre>
  converts a single lower case ascii character stored in  <code>c</code>
  to  upper case,  making  use  of the fact that corresponding ascii
  letters are a fixed distance apart.&#160;<tt> </tt>The rule governing
  this arithmetic is that all chars  are  converted to <code>int</code>
  before the arithmetic is done.&#160;<tt> </tt>Beware
  that  conversion may  involve sign-extension if  the leftmost bit of a
  character  is  1,  the  resulting  integer  might be negative.&#160;<tt> </tt>
  (This doesn't happen with genuine characters on any current machine.)
<p>
       So to convert a file into lower case:
<pre>
       main( ) {
               char c;
               while( (c=getchar( )) != '\0' )
                       if( 'A'&lt;=c &amp;&amp; c&lt;='Z' )
                               putchar(c+'a'-'A');
                       else
                               putchar(c);
       }
</pre>
  Characters have different  sizes  on  different  machines.&#160;<tt> </tt>Further,
  this code won't work on an IBM machine,  because the  letters  in  the
  ebcdic alphabet are not contiguous.
<p>
<p>
<h2>
                 9.&#160;<tt> </tt><a name="else">Else Clause</a>;
		 Conditional Expressions
</h2>
      We  just used an <code>else</code> after an  <code>if</code>.&#160;<tt> </tt>
      The  most  general form of <code>if</code> is
<pre>
       if (<i>expression</i>) <i>statement1</i> else <i>statement2</i>
</pre>
  the <code>else</code> part is optional, but often useful.&#160;<tt> </tt>
  The  canonical example sets <code>x</code> to the minimum of <code>a</code>
  and <code>b</code>:
<pre>
       if (a &lt; b)
               x = a;
       else
               x = b;
</pre>
  Observe that there's a semicolon after <code>x=a</code>.
<p>
       <a name="conditional">C provides an alternate form of conditional</a>
  which   is  often more concise.&#160;<tt> </tt>
  It is called the ``conditional expression'' because it
  is a conditional  which  actually   has   a  value  and  can  be  used
  anywhere an expression can.&#160;<tt> </tt>The value of
<pre>
       a&lt;b ? a : b;
</pre>
  is <code>a</code> if <code>a</code> is less than <code>b</code>; it
  is <code>b</code>  otherwise.&#160;<tt> </tt>In  general, the form
<pre>
       <i>expr1</i> ? <i>expr2</i> : <i>expr3</i>
</pre>
  means  ``evaluate  <code>expr1</code>.&#160;<tt> </tt>If it is not zero,
  the value of the whole thing is <code>expr2</code>; otherwise the value
  is <code>expr3</code>.''
<p>
       To set <code>x</code> to the minimum of <code>a</code> and
       <code>b</code>, then:
<pre>
       x = (a&lt;b ? a : b);
</pre>
  The parentheses aren't necessary because `?:'   is   evaluated  before
  `=', but safety first.
<p>
       Going  a  step further,  we could write the  loop  in  the
       lower-case program as
<pre>
       while( (c=getchar( )) != '\0' )
               putchar( ('A'&lt;=c &amp;&amp; c&lt;='Z') ? c-'A'+'a' : c );
</pre>
<p>
       If's and else's can be used  to  construct  logic  that  branches
  one of several ways and then rejoins, a common programming structure,
  in this way:
<pre>
       if(...)
               {...}
       else if(...)
               {...}
       else if(...)
               {...}
       else
               {...}
</pre>
  The conditions are tested in order, and exactly one block is executed;
  either  the first one whose if is satisfied,  or the one for the  last
  <code>else</code>.&#160;<tt> </tt>When this block is finished, the next
  statement executed is the one after the last else.&#160;<tt> </tt>
  If  no  action  is  to  be  taken  for  the ``default'' case, omit
  the last <code>else</code>.
<p>
       For example,  to count letters, digits and others  in  a file, we
  could write
<pre>
  main( ) {
          int let, dig, other, c;
          let = dig = other = 0;
          while( (c=getchar( )) != '\0' )
                  if( ('A'&lt;=c &amp;&amp; c&lt;='Z') || ('a'&lt;=c &amp;&amp;  c&lt;='z') )
                        ++let;
                  else if( '0'&lt;=c &amp;&amp; c&lt;='9' ) ++dig;
                  else  ++other;
          printf(&quot;%d letters, %d digits, %d others\n&quot;, let, dig, other);
  }
</pre>
  The `++' operator means ``increment by 1''; we will  get  to it in the
  next section.
<p>
<p>
<h2>
                  10.&#160;<tt> </tt><a name="increment">Increment</a> and Decrement Operators
</h2>
       In  addition  to  the  usual  `-',   C   also   has   two   other
  interesting  unary    operators,    `++'    (increment)    and    `--'
  (decrement).&#160;<tt> </tt>Suppose we want to count the lines in a file.
<pre>
       main( ) {
               int c,n;
               n = 0;
               while( (c=getchar( )) != '\0' )
                       if( c == '\n' )
                               ++n;
               printf(&quot;%d lines\n&quot;, n);
       }
</pre>
  <code>++n</code> is equivalent to <code>n=n+1</code> but clearer,
  particularly when   <code>n</code>  is   a
  complicated  expression.&#160;<tt> </tt>`++'  and `--' can be applied only to
  int's and char's (and <a href="#pointers">pointers</a> which we haven't
  got to yet).
<p>
       The unusual feature of `++' and `--' is that  they  can  be  used
  either before or after a variable.&#160;<tt> </tt>The value of <code>++k</code>
  is the value of <code>k</code> <em>after</em> it has been
  incremented.&#160;<tt> </tt>The  value of <code>k++ </code>is <code>k</code>
  <em>before</em>  it  is incremented.&#160;<tt> </tt>Suppose <code>k</code>
  is 5.&#160;<tt> </tt>Then
<pre>
       x = ++k;
</pre>
  increments <code>k</code> to 6 and then sets <code>x</code> to 
  the  resulting  value, i.e., to 6.&#160;<tt> </tt>But
<pre>
       x = k++;
</pre>
  first sets <code>x</code>  to  to  5,  and   <em>then</em> 
  increments   <code>k</code>   to   6.&#160;<tt> </tt>The
  incrementing effect  of  <code>++k</code> and <code>k++</code> is
  the same, but their values are respectively 5 and 6.&#160;<tt> </tt>
  We shall soon see examples where both of these uses are important.
<p>
<p>
<h2>
                                11.&#160;<tt> </tt><a name="array">Arrays</a>
</h2>
       In C,  as in Fortran or PL/I,  it  is  possible  to  make arrays
  whose elements are basic types.&#160;<tt> </tt>Thus we can  make  an  array 
  of  10 integers with the declaration
<pre>
       int x[10];
</pre>
  The square brackets mean subscripting; parentheses are  used only  for
  function references.&#160;<tt> </tt>Array indexes begin at zero, so the
  elements of <code>x</code> are
<pre>
       x[0], x[1], x[2], ..., x[9]
</pre>
  If an array has <i>n</i> elements, the largest subscript is
  <i>n-1</i>.
<p>
       Multiple-dimension arrays are provided,  though  not  much  used
  above two  dimensions.&#160;<tt> </tt>The declaration and use look like
<pre>
       int name[10] [20];
       n = name[i+j] [1] + name[k] [2];
</pre>
  Subscripts can be  arbitrary  integer  expressions.&#160;<tt> </tt>
  Multi-dimension
  arrays  are  stored  by  row  (opposite to Fortran),  so the rightmost
  subscript varies fastest; name has 10 rows and 20 columns.
<p>
       Here is a program which reads a line,  stores  it  in  a buffer,
  and prints its length (excluding the newline at the end).
<pre>
       main( ) {
               int n, c;
               char line[100];
               n = 0;
               while( (c=getchar( )) != '\n' ) {
                       if( n &lt; 100 )
                               line[n] = c;
                       n++;
               }
               printf(&quot;length = %d\n&quot;, n);
       }
</pre>
<p>
       As a more complicated problem,  suppose we  want  to  print  the
  count  for  each   line   in  the  input,  still storing the first 100
  characters of each line.&#160;<tt> </tt>Try it  as  an  exercise before looking  at
  the solution:
<pre>
       main( ) {
               int n, c; char line[100];
               n = 0;
               while( (c=getchar( )) != '\0' )
                       if( c == '\n' ) {
                               printf(&quot;%d0, n);
                               n = 0;
                       }
                       else {
                               if( n &lt; 100 ) line[n] = c;
                               n++;
                       }
       }
</pre>
<p>
<h2>
       12.&#160;<tt> </tt><a name="character-array">Character Arrays</a>; Strings
</h2>
       Text is usually kept as an array of characters,  as  we did  with
  <code>line[ ]</code> in the example above.&#160;<tt> </tt>By convention in C,
  the last character
  in  a  character  array should be a `\0' because  most  programs that
  manipulate  character  arrays expect  it.&#160;<tt> </tt>For  example,
  <code>printf</code> uses the `\0' to detect  the end of a character
  array when printing it out with a `%s'.
<p>
       <a name="copy-example">We can</a> copy a character array <code>s</code>
       into another <code>t</code> like this:
<pre>
               i = 0;
               while( (t[i]=s[i]) != '\0' )
                       i++;
</pre>
<p>
       Most  of the time we have to put in our own `\0' at  the end  of
  a string;  if we want to print the line with <code>printf</code>,  it's
  necessary.&#160;<tt> </tt>This code prints the character count before the line:
<pre>
       main( ) {
               int n;
               char line[100];
               n = 0;
               while( (line[n++]=getchar( )) != '\n' );
               line[n] = '\0';
               printf(&quot;%d:\t%s&quot;, n, line);
       }
</pre>
  Here we increment <code>n</code> in the subscript  itself,
  but  only   after  the previous  value   has  been  used.&#160;<tt> </tt>
  The character is read,  placed in
  <code>line[n]</code>, and only then <code>n</code> is incremented.
<p>
       There is one place and one place only where C  puts  in the  `\0'
  at  the  end  of  a  character  array  for  you,  and  that  is in the
  construction
<pre>
       &quot;stuff between double quotes&quot;
</pre>
  The compiler puts a `\0' at  the  end  automatically.&#160;<tt> </tt>Text enclosed
  in  double  quotes  is  called  a  <em>string</em>;  its  properties  are
  precisely those of an (initialized) array of characters.
<p>
<h2>
                            13.&#160;<tt> </tt><a name="for">For Statement</a>
</h2>
       The <code>for</code> statement is a somewhat generalized
   <code>while</code>  that  lets  us
  put  the  initialization  and  increment parts of a loop into a single
  statement along with the  test.&#160;<tt> </tt>The  general form of the
  <code>for</code> is
<pre>
       for( <i>initialization</i>; <i>expression</i>; <i>increment</i> )
               <i>statement</i>
</pre>
  The meaning is exactly
<pre>
        <i>initialization</i>;
        while( <i>expression</i> ) {
               <i>statement</i>
               <i>increment</i>;
        }
</pre>
  Thus,  the  following code does the same  array  copy  as
  <a href="#copy-example">the example in the previous section</a>:
<pre>
        for( i=0; (t[i]=s[i]) != '\0'; i++ );
</pre>
  This slightly more ornate example adds up the elements of an array:
<pre>
        sum = 0;
        for( i=0; i&lt;n; i++)
               sum = sum + array[i];
</pre>
<p>
       In the for statement,  the initialization  can  be  left out  if
  you want,  but the semicolon has to be there.&#160;<tt> </tt>The increment is also
  optional.&#160;<tt> </tt>It is <em>not</em> followed by  a  semicolon.&#160;<tt> </tt>
  The  second clause,
  the test, works the same way as in the <code>while</code>:  if 
  the  expression  is true   (not   zero)  do another  loop,  otherwise get
  on with the next statement.&#160;<tt> </tt>As with the <code>while</code>,
  the for loop may be done zero times.&#160;<tt> </tt>If the expression is left out,
  it is taken to be always true, so
<pre>
        for( ; ; ) ...
</pre>
  and
<pre>
        while( 1 ) ...
</pre>
  are both infinite loops.
<p>
       You  might ask why we use a <code>for</code> since it's so much
       like a <code>while</code>.&#160;<tt> </tt>
  (You might also ask why we use a <code>while</code> because...)&#160;<tt> </tt>
&#160;<tt> </tt>The <code>for</code> is  usually
  preferable  because   it   keeps   the   code  where   it's   used and
  sometimes eliminates the need for compound  statements,   as  in  this
  code  that  zeros  a two-dimensional array:
<pre>
        for( i=0; i&lt;n; i++ )
               for( j=0; j&lt;m; j++ )
                       array[i][j] = 0;
</pre>
<p>
<h2>
                         14.&#160;<tt> </tt><a name="functions">Functions; Comments</a>
</h2>
       Suppose we want,  as part of a  larger  program,  to   count  the
  occurrences of the ascii characters in some input text.&#160;<tt> </tt>Let us also
  map illegal characters (those with value&gt;127  or &lt;0)  into  one  pile.&#160;<tt> </tt>
  Since  this  is  presumably  an  isolated  part of the program,  good
  practice dictates making  it  a separate function.&#160;<tt> </tt>Here is one way:
<pre>
       main( ) {
               int hist[129];      /*  128 legal chars + 1 illegal group*/
               ...
               count(hist, 128);   /* count the letters into hist */
               printf( ... );      /* comments look like this; use them */
               ...        /* anywhere blanks, tabs or newlines could appear */
       }

       count(buf, size)
          int size, buf[ ]; {
               int i, c;
               for( i=0; i&lt;=size; i++ )
                       buf[i]  =  0;                     /*  set buf to zero */
               while(  (c=getchar(  )) != '\0' ) {       /* read til eof */
                       if( c &gt; size || c &lt; 0 )
                               c = size;                 /* fix illegal input */
                       buf[c]++;
               }
               return;
       }
</pre>
  We  have already seen many examples of calling a function,  so let  us
  concentrate  on how to define one.&#160;<tt> </tt>Since <code>count</code>
  has two arguments, we need to declare  them, as shown, giving their types,
  and in the
  case of <code>buf</code>, the fact that it is an array.&#160;<tt> </tt>The
  declarations of
  arguments go between the argument  list and the opening `{'.&#160;<tt> </tt>There
  is no need to specify the size of the array <code>buf</code>,
  for it is defined outside of count.
<p>
       The  return  statement  simply  says  to  go back to the calling
  routine.&#160;<tt> </tt>In fact, we could have omitted it, since a return is implied
  at the end of a function.
<p>
       What  if we wanted <code>count</code> to  return  a  value,
       say  the number of characters read?&#160;<tt> </tt>The return statement
       allows for this too:
<pre>
               int i, c, nchar;
               nchar = 0;
               ...
               while( (c=getchar( )) != '\0' ) {
                       if( c &gt; size || c &lt; 0 )
                               c = size;
                       buf[c]++;
                       nchar++;
               }
               return(nchar);
</pre>
  Any expression can appear within the parentheses.&#160;<tt> </tt>Here is a  function
  to compute the minimum of two integers:
<pre>
       min(a, b)
          int a, b; {
               return( a &lt; b ? a : b );
       }
</pre>
<p>
<p>
       To copy a character array, we could write the function
<pre>
       strcopy(s1, s2)         /* copies s1 to s2 */
          char s1[ ], s2[ ]; {
               int i;
               for( i = 0; (s2[i] = s1[i]) != '\0'; i++ );
       }
</pre>
  As is often the case, all the work is done by the assignment statement
  embedded in the test part of the for.&#160;<tt> </tt>Again, the declarations of the
  arguments s1  and  s2  omit  the  sizes,  because  they  don't  matter
  to <code>strcopy</code>.&#160;<tt> </tt>(In the <a href="#pointers">section on
  pointers</a>, we will see a more efficient way to do a string copy.)
<p>
       There is a subtlety in  function  usage   which   can   trap  the
  unsuspecting Fortran programmer.&#160;<tt> </tt>Simple variables (not arrays) are
  passed in C by ``call by  value'',   which  means  that   the   called
  function  is  given  a  copy of its arguments,  and doesn't know their
  addresses.&#160;<tt> </tt>This makes it  impossible to change the value of  one 
  of the actual input arguments.
<p>
       There  are two ways out of this dilemma.&#160;<tt> </tt>One is to make special
  arrangements to pass to the function the address of a variable instead
  of its value.&#160;<tt> </tt>The  other  is to  make  the variable  a  global  or
  external variable, which is known to each function by its name.&#160;<tt> </tt>We
  will discuss both  possibilities in the next few sections.
<p>
<h2>
                  15.&#160;<tt> </tt><a name="variables">Local and External</a> Variables
</h2>
       If we say
<pre>
       f( ) {
               int x;
               ...
       }
       g( ) {
               int x;
               ...
       }
</pre>
  each <code>x</code> is <em>local</em> to its own routine -- the <code>x</code>
  in <code>f</code> is unrelated to  the <code>x</code> in
  <code>g</code>.&#160;<tt> </tt>(Local variables are also called
  ``automatic''.)&#160;<tt> </tt>
  Furthermore each local variable in a routine appears  only  when   the
  function  is  called,  and  <em>disappears</em>  when the function is
  exited.&#160;<tt> </tt>Local variables have no memory from one call to the next and
  must be explicitly initialized upon each entry.&#160;<tt> </tt>(There is a
  <code>static</code> storage class for making local variables  with  memory;
  we  won't discuss it.)
<p>
       As  opposed to local variables,  external  variables  are defined
  external  to  all  functions,  and are (potentially) available to  all
  functions.&#160;<tt> </tt>External  storage always remains in 
  existence.&#160;<tt> </tt>To make
  variables external we have to define them external to  all  functions,
  and, wherever we want to use them, make a declaration.
<pre>
       main( ) {
               extern int nchar, hist[ ];
               ...
               count( );
               ...
       }

       count( ) {
               extern int nchar, hist[ ];
               int i, c;
               ...
       }

       int     hist[129];      /* space for histogram */
       int     nchar;          /* character count */
</pre>
  Roughly speaking,  any function  that  wishes  to  access  an external
  variable must contain an extern declaration for it.&#160;<tt> </tt>The declaration
  is the same as others, except for the added keyword
  <code>extern</code>.&#160;<tt> </tt>
  Furthermore,  there must  somewhere be a definition  of  the  external
  variables external to  all functions.
<p>
       External variables can be initialized;  they are set  to zero  if
  not explicitly initialized.&#160;<tt> </tt>In its simplest form, initialization is
  done  by  putting  the  value  (which  must  be  a constant) after the
  definition:
<pre>
       int     nchar   0;
       char    flag    'f';
         <i>etc.</i>
</pre>
  This is discussed further in a <a href="#initialization">later section</a>.
<p>
<p>
       This  ends our discussion of what might  be  called  the central
  core of C.&#160;<tt> </tt>You now have enough to write quite substantial C programs,
  and  it would probably be a good idea if you  paused long enough to do
  so.&#160;<tt> </tt>The rest  of  this  tutorial will describe some more ornate
  constructions, useful but not essential.
<p>
<h2>
                               16.&#160;<tt> </tt><a name="pointers">Pointers</a>
</h2>
       A  pointer  in  C is the address of something.&#160;<tt> </tt>It is a rare
  case indeed  when  we  care what the specific address itself  is,  but
  pointers are a quite common way to get at the contents  of  something.&#160;<tt> </tt>
  The unary operator `&amp;' is used to produce the address of an object, if
  it has one.&#160;<tt> </tt>Thus
<pre>
          int a, b;
          b = &amp;a;
</pre>
  puts the address of <code>a</code> into <code>b</code>.&#160;<tt> </tt>
  We  can't  do  much  with   it  except
  print it or pass it to some other routine,  because we haven't given
  <code>b</code> the right kind of declaration.&#160;<tt> </tt>
  But  if   we  declare   that   <code>b</code>  is indeed a pointer
  to an integer, we're in good shape:
<pre>
          int a, *b, c;
          b = &amp;a;
          c = *b;
</pre>
  <code>b</code>  contains the address of <code>a</code> and `c = *b' means
  to  use  the value in
  <code>b</code> as an address,  i.e.,  as a pointer.&#160;<tt> </tt>
  The effect is that  we   get
  back the contents   of   <code>a</code>, albeit rather indirectly.&#160;<tt> </tt>
  (It's always the case that `*&amp;x' is the same as <code>x</code> if
  <code>x</code> has an address.)
<p>
       The  most  frequent  use  of  pointers  in  C  is   for   walking
  efficiently along arrays.&#160;<tt> </tt>In fact, in the implementation of an array,
  the array  name represents  the  address  of  the  zeroth  element  of
  the array, so you can't use it on the left side of an expression.&#160;<tt> </tt>
  (You can't  change  the  address of something by assigning to it.)&#160;<tt> </tt>
  If we say
<pre>
       char *y;
       char x[100];
</pre>
  <code>y</code> is of type pointer to character (although it doesn't yet
  point anywhere).&#160;<tt> </tt>We can make <code>y</code> point to an element
  of <code>x</code> by either of
<pre>
       y = &amp;x[0];
       y = x;
</pre>
  Since <code>x</code> is the address of <code>x[0]</code> this is
  legal and consistent.
<p>
       Now `*y' gives x[0].&#160;<tt> </tt>More importantly,
<pre>
       *(y+1)  gives x[1]
       *(y+i)  gives x[i]
</pre>
  and the sequence
<pre>
               y = &amp;x[0];
               y++;
</pre>
  leaves <code>y</code> pointing at x[1].
<p>
       Let's use pointers in a function length  that  computes how  long
  a  character  array  is.&#160;<tt> </tt>Remember  that  by convention all
  character
  arrays are terminated with  a   `\0'.&#160;<tt> </tt>(And   if  they   aren't,
  this program will blow up inevitably.)&#160;<tt> </tt>The old way:
<pre>
       length(s)
          char s[ ]; {
               int n;
               for( n=0; s[n] != '\0'; )
                       n++;
               return(n);
       }
</pre>
  Rewriting with pointers gives
<pre>
       length(s)
          char *s; {
               int n;
               for( n=0; *s != '\0'; s++ )
                       n++;
               return(n);
       }
</pre>
  You  can  now see why we have to say  what  kind  of  thing  <code>s</code>
  points to -- if we're to increment it with <code>s++</code> we have to
  increment  it  by  the right amount.
<p>
       The  pointer  version  is more efficient (this  is  almost always
  true) but even more compact is
<pre>
               for( n=0; *s++ != '\0'; n++ );
</pre>
  The `*s'  returns  a  character;   the  `++'  increments  the pointer
  so we'll  get the next character next time around.&#160;<tt> </tt>As you can see,
  as we make things more  efficient, we  also make them less clear.&#160;<tt> </tt>
  But `*s++' is an idiom so common that you have to know it.
<p>
<p>
       <a name="strcopy">Going a step further,</a> here's our function
    strcopy  that copies a character array s to another t.
<pre>
       strcopy(s,t)
          char *s, *t; {
               while(*t++ = *s++);
       }
</pre>
  We  have  omitted  the   test   against   `\0',    because   `\0'   is
  identically zero;  you  will  often  see the code this way.&#160;<tt> </tt>(You
  <em>must</em>
  have a space after the `=': see <a href="#assignment">section 25</a>.)
<p>
       For  arguments   to   a   function,    and   there   only,    the
  declarations
<pre>
       char s[ ];
       char *s;
</pre>
  are  equivalent  --  a   pointer   to   a   type,   or   an   array  of
  unspecified size of that type, are the same thing.
<p>
       If this all seems mysterious,  copy  these   forms   until  they
  become   second  nature.&#160;<tt> </tt>You   don't  often  need  anything  more
  complicated.
<p>
<p>
<h2>
                          17.&#160;<tt> </tt><a name="argument">Function Arguments</a>
</h2>
       Look back at the <a href="#strcopy">function strcopy in the previous
  section</a>.&#160;<tt> </tt>We
  passed  it  two  string names as arguments,  then proceeded to clobber
  both of them by  incrementation.&#160;<tt> </tt>So   how  come  we  don't
  lose  the original strings in the function that called strcopy?
<p>
       As we said before, C is a ``call by  value''  language: when  you
  make a function call like f(x),  the <em>value</em> of <code>x</code>
  is  passed,  not  its address.&#160;<tt> </tt>So  there's  no way to <em>alter</em>
  <code>x</code>  from inside  <code>f</code>.&#160;<tt> </tt>If <code>x</code>
  is an array (char x[10]) this isn't a  problem,  because  <code>x</code>
  <em>is</em>  an  address anyway,  and you're not trying to  change  it,
  just what it addresses.&#160;<tt> </tt>
  This is why <code>strcopy</code> works as it does.&#160;<tt> </tt>
  And it's convenient not to have to  worry about making temporary
  copies of the input arguments.
<p>
But what if <code>x</code> is a scalar and you do want to change it?&#160;<tt> </tt>
   In  that
  case,  you have to pass the <em>address</em> of <code>x</code> to
  <code>f</code>,  and then use it  as  a pointer.&#160;<tt> </tt>Thus
  for  example,  to  interchange two integers,  we must
  write
<pre>
   flip(x, y)
      int *x, *y; {
           int temp;
           temp = *x;
           *x = *y;
           *y = temp;
   }
</pre>
  and to call <code>flip</code>, we have to pass the addresses of the variables:
<pre>
       flip (&amp;a, &amp;b);
</pre>
<p>
<p>
<h2>
          18.&#160;<tt> </tt><a name="multiple-level">Multiple Levels of Pointers</a>;
	  Program Arguments
</h2>
       When  a C program is called,  the arguments on  the  command line
  are made available to the main program as an argument count <code>argc</code>
  and an  array  of  character  strings  <code>argv</code> containing
  the arguments.&#160;<tt> </tt>
  Manipulating these arguments is one of  the  most  common   uses   of
  multiple  levels  of pointers (``pointer  to  pointer to ...'').&#160;<tt> </tt>By
  convention,  <code>argc</code> is  greater  than  zero;  the  first s
  argument  (in <code>argv[0]</code>) is  the command name itself.
<p>
       Here is a program that simply echoes its arguments.
<pre>
       main(argc, argv)
          int argc;
          char **argv; {
               int i;
               for( i=1; i &lt; argc; i++ )
       }
</pre>
  Step by step:  <code>main</code> is called with two arguments,
  the  argument count
  and  the  array  of arguments.&#160;<tt> </tt><code>argv</code> is a
  pointer to an array, whose
  individual elements are pointers to arrays  of   characters.&#160;<tt> </tt>
  The zeroth  argument  is  the  name of the command itself,  so we start to
  print with the  first argument, until  we've  printed them all.&#160;<tt> </tt>Each
  argv[i] is a character array, so we use a `%s' in the <code>printf</code>.
<p>
       You will sometimes see the declaration of <code>argv</code>  written as
<pre>
       char *argv[ ];
</pre>
  which is equivalent.&#160;<tt> </tt>But we can't  use
  <code>char argv[  ][  ]</code>, because
  both  dimensions  are variable and there would be no way to figure out
  how big the array is.
<p>
       Here's  a  bigger  example  using  <code>argc</code>  and 
       <code>argv</code>.&#160;<tt> </tt>A common
  convention   in  C  programs is that if the first argument is `-', it
  indicates a flag of some sort.&#160;<tt> </tt>For example, suppose we want a program
  to be callable as
<pre>
       prog -abc arg1 arg2 ...
</pre>
  where  the  `-'  argument  is  optional;  if it is present,  it may be
  followed by any combination of a, b, and c.
<pre>
       main(argc, argv)
          int argc;
          char **argv; {
               ...
               aflag = bflag = cflag  = 0;
               if( argc &gt; 1 &amp;&amp; argv[1][0] == '-' ) {
                       for( i=1; (c=argv[1][i]) != '\0'; i++ )
                               if( c=='a' )
                                       aflag++;
                               else if( c=='b' )
                                       bflag++;
                               else if( c=='c' )
                                       cflag++;
                               else
                                       printf(&quot;%c?\n&quot;, c);
                       --argc;
                       ++argv;
               }
               ...
</pre>
<p>
       There  are several  things  worth  noticing  about  this code.&#160;<tt> </tt>
  First,   there  is  a real need for the left-to-right evaluation  that
  &amp;&amp;   provides;   we   don't  want  to  look  at <code>argv[1]</code>
  unless we know it's there.&#160;<tt> </tt>Second, the statements
<pre>
               --argc;
               ++argv;
</pre>
  let us march along the argument list by one position,  so  we can skip
  over the flag argument as if it had never existed;  the  rest  of  the
  program  is  independent   of   whether   or   not  there   was a flag
  argument.&#160;<tt> </tt>This only works because <code>argv</code> is a 
  pointer  which  can  be incremented.
<p>
<p>
<h2>
                19.&#160;<tt> </tt><a name="switch">The Switch Statement</a>;
			Break; Continue
</h2>
       The  switch statement can be used to replace the  multi-way  test
  we used in the last example.&#160;<tt> </tt>When the tests are
  like this:
<pre>
       if( c == 'a' ) ...
       else if( c == 'b' ) ...
       else if( c == 'c' ) ...
       else ...
</pre>
  testing a value against a series of  constants,  the  switch statement
  is often  clearer and usually gives better code.&#160;<tt> </tt>Use it like this:
<pre>
       switch( c ) {

       case 'a':
               aflag++;
               break;
       case 'b':
               bflag++;
               break;
       case 'c':
               cflag++;
               break;
       default:
               printf(&quot;%c?\n&quot;, c);
               break;
       }
</pre>
<p>
  The case statements  label  the  various  actions  we  want; 
  <code>default</code>
  gets done if none of the other cases  are  satisfied.&#160;<tt> </tt>(A
  <code>default</code> is
  optional;  if it isn't there,  and none  of  the cases match, you just
  fall out the bottom.)
<p>
       The break statement in this  example  is  new.&#160;<tt> </tt>It   is  there
  because the  cases are just labels,  and after you do one of them, you
  fall through to the next  unless  you  take some  explicit  action  to
  escape.&#160;<tt> </tt>This is a mixed blessing.&#160;<tt> </tt>On the positive side,
  you can have multiple cases on a single  statement;
  we might want to  allow  both upper and lower
<pre>
       case 'a':  case 'A':    ...

       case 'b':  case 'B':    ...
        <i>etc.</i>
</pre>
  But what if we just want to get out after doing case  `a' ?  We  could
  get  out of a <code>case</code> of the <code>switch</code> with a label
  and a <code>goto</code>,  but this is really ugly.&#160;<tt> </tt>The break
  statement lets  us exit without either <code>goto</code> or label.
<pre>
       switch( c ) {

       case 'a':
               aflag++;
               break;
       case 'b':
               bflag++;
               break;
        ...
       }
       /* the break statements get us here directly */
</pre>
  The break statement also works in for and while statements;  it causes
  an immediate exit from the loop.
<p>
       The continue  statement   works   <em>only</em>  inside
       <code>for</code>'s   and <code>while</code>'s;
       it  causes  the  next  iteration of the loop to be started.&#160;<tt> </tt>
  This means it goes to the increment  part  of  the <code>for</code>  and
  the  test part of the <code>while</code>.&#160;<tt> </tt>We could have used
  a continue in our example to get on with the next iteration of the
  <code>for</code>, but it seems  clearer  to  use
  <code>break</code> instead.
<p>
<p>
<h2>
                              20.&#160;<tt> </tt><a name="structure">Structures</a>
</h2>
       The  main  use of structures is to lump together  collections  of
  disparate variable types,  so they can conveniently be  treated  as  a
  unit.&#160;<tt> </tt>For example, if  we  were  writing  a compiler  or  assembler,
  we  might need for  each  identifier  information  like  its  name  (a
  character  array),  its  source line  number  (an integer),  some type
  information  (a  character,  perhaps),  and  probably  a  usage  count
  (another integer).
<pre>
               char    id[10];
               int     line;
               char    type;
               int     usage;
</pre>
<p>
       We  can  make a structure out of this quite  easily.&#160;<tt> </tt>We first
  tell  C what  the structure will look like,  that is,  what  kinds  of
  things it contains;  after that we can actually reserve  storage  for
  it,  either  in the same statement or separately.&#160;<tt> </tt>The simplest thing
  is to define it and allocate storage all at once:
<pre>
       struct {
               char    id[10];
               int     line;
               char    type;
               int     usage;
       } sym;
</pre>
<p>
       This  defines  sym to be a structure with  the  specified shape;
  <code>id</code>,  <code>line</code>,  <code>type</code> and <code>usage</code>
  are members of the structure.&#160;<tt> </tt>The way we
  refer to any  particular  member  of  the structure is
<pre>
       structure-name . member
</pre>
  as in
<pre>
               sym.type = 077;
               if( sym.usage == 0 ) ...
               while( sym.id[j++] ) ...
                  <i>etc.</i>
</pre>
  Although the names of structure members  never   stand   alone,  they
  still  have  to be unique;  there can't be another id or usage in some
  other structure.
<p>
      So  far  we   haven't   gained   much.&#160;<tt> </tt>The   advantages of
  structures start to come when we have arrays of structures, or when we
  want to pass complicated  data  layouts  between functions.&#160;<tt> </tt>
  Suppose we wanted to make a symbol table for up to 100
  identifiers.&#160;<tt> </tt>We could
  extend our definitions like
<pre>
               char    id[100][10];
               int     line[100];
               char    type[100];
               int     usage[100];
</pre>
  but  a  structure lets us rearrange this  spread-out  information  so
  all the data about a single identifer is collected into one lump:
<pre>
       struct {
               char    id[10];
               int     line;
               char    type;
               int     usage;
       } sym[100];
</pre>
  This  makes sym an array of structures;   each  array  element has the
  specified shape.&#160;<tt> </tt>Now we can refer to members as
<pre>
               sym[i].usage++; /* increment usage of i-th identifier */
               for( j=0; sym[i].id[j++] != '\0'; ) ...
                  <i>etc.</i>
</pre>
  Thus to print a list of all identifiers   that   haven't   been  used,
  together with their line number,
<pre>
            for( i=0; i&lt;nsym; i++ )
                    if( sym[i].usage == 0 )
                            printf(&quot;%d\t%s\n&quot;, sym[i].line, sym[i].id);
</pre>
<p>
       Suppose we now want to write  a   function   lookup(name)  which
  will  tell us if name already exists in <code>sym</code>,
  by giving its index,  or
  that it doesn't, by returning a -1.&#160;<tt> </tt>We  can't pass 
  a structure to a
  function directly;  we have to either define it externally,  or pass a
  pointer to it.&#160;<tt> </tt>Let's  try the first way first.
<pre>
       int     nsym    0;      /* current length of symbol table */

       struct {
               char    id[10];
               int     line;
               char    type;
               int     usage;
       } sym[100];             /* symbol table */

       main( ) {
               ...
               if( (index = lookup(newname)) &gt;= 0 )
                       sym[index].usage++;              /* already there ... */
               else
                       install(newname, newline, newtype);
               ...
       }

       lookup(s)
          char *s; {
               int i;
               extern struct {
                       char    id[10];
                       int     line;
                       char    type;
                       int     usage;
               } sym[ ];

               for( i=0; i&lt;nsym; i++ )
                       if( compar(s, sym[i].id) &gt; 0 )
                               return(i);
               return(-1);
       }

       compar(s1,s2)           /*  return 1 if s1==s2, 0 otherwise */
          char *s1, *s2; {
               while( *s1++ == *s2 )
                       if( *s2++ == '\0' )
                               return(1);
               return(0);
       }
</pre>
<p>
  The  declaration  of  the  structure  in lookup isn't  needed  if the
  external definition precedes its use in the same source  file,  as  we
  shall see in a moment.
<p>
       Now what if we want to use pointers?
<pre>
       struct  symtag {
               char    id[10];
               int     line;
               char    type;
               int     usage;
       } sym[100], *psym;

               psym = &amp;sym[0]; /* or p = sym; */
</pre>
  This makes <code>psym</code> a pointer  to  our  kind  of  structure 
  (the  symbol table), then initializes it to point to the first element
  of <code>sym</code>.
<p>
       Notice  that we added something after the word struct:  a ``tag''
  called symtag.&#160;<tt> </tt>This puts a name on our structure definition
  so we can
  refer  to  it  later  without  repeating the definition.&#160;<tt> </tt>
  It's  not necessary but useful.&#160;<tt> </tt>In fact we could have said
<pre>
       struct  symtag {
               ... structure definition
       };
</pre>
  which wouldn't have assigned any storage at all, and then said
<pre>
       struct  symtag  sym[100];
       struct  symtag  *psym;
</pre>
  which would define the array and the pointer.&#160;<tt> </tt>This could be
  condensed further, to
<pre>
       struct  symtag  sym[100], *psym;
</pre>
<p>
       The  way  we  actually  refer  to  an  member of a structure by a
  pointer is like this:
<pre>
               ptr -&gt; structure-member
</pre>
  The  symbol  `-&gt;'  means   we're   pointing   at   a   member   of   a
  structure; `-&gt;'  is  only  used  in that context.&#160;<tt> </tt><code>ptr</code>
  is a pointer to
  the (base  of) a  structure  that  contains  the  structure  member.&#160;<tt> </tt>
  The   expression  ptr-&gt;structure-member refers to the indicated member
  of the pointed-to structure.&#160;<tt> </tt>Thus we have constructions like:
<pre>
       psym-&gt;type = 1;
       psym-&gt;id[0] = 'a';
</pre>
  and so on.
<p>
       For  more  complicated  pointer  expressions,  it's  wise  to use
  parentheses  to  make it clear who goes with what.&#160;<tt> </tt>For example,
<pre>
       struct { int x, *y; } *p;
       p-&gt;x++  increments x
       ++p-&gt;x  so does this!
       (++p)-&gt;x        increments p before getting x
       *p-&gt;y++ uses y as a pointer, then increments it
       *(p-&gt;y)++       so does this
       *(p++)-&gt;y       uses y as a pointer, then increments p
</pre>
  The way to remember these is that -&gt;,  .  (dot),  ( ) and  [  ]  bind
  very  tightly.&#160;<tt> </tt>An  expression involving one of these is treated as a
  unit.&#160;<tt> </tt><code>p-&gt;x</code>, <code>a[i]</code>,  <code>y.x</code>
  and  <code>f(b)</code>  are  names exactly as <code>abc</code> is.
<p>
       If <code>p</code> is a pointer to a structure,  any arithmetic  on
       <code>p</code>  takes
  into  account   the actual size of the structure.&#160;<tt> </tt>For instance,
  <code>p++</code> increments <code>p</code> by the correct amount to get
  the next  element   of  the
  array of structures.&#160;<tt> </tt>But don't assume that the size of a structure is
  the sum of the sizes of  its  members   --  because  of  alignments  of
  different sized objects, there may be ``holes'' in a structure.
<p>
      Enough  theory.&#160;<tt> </tt>Here  is  the  lookup   example,  this time with
  pointers.
<pre>
       struct symtag {
               char    id[10];
               int     line;
               char    type;
               int     usage;
       } sym[100];

       main( ) {
               struct symtag *lookup( );
               struct symtag *psym;
               ...
               if( (psym = lookup(newname)) )  /* non-zero pointer */
                       psym -&gt; usage++;                 /* means already
  there */
               else
                       install(newname, newline, newtype);
               ...
       }

       struct symtag *lookup(s)
          char *s; {
               struct symtag *p;
               for( p=sym; p &lt; &amp;sym[nsym]; p++ )
                       if( compar(s, p-&gt;id) &gt; 0)
                               return(p);
               return(0);
       }
</pre>
  The function compar doesn't  change:  `p-&gt;id'  refers  to  a string.
<p>
       In <code>main</code> we test the pointer returned by  <code>lookup</code>
       against  zero,
  relying  on   the fact that a pointer is by definition never zero when
  it really points at  something.&#160;<tt> </tt>The  other pointer manipulations are
  trivial.
<p>
       The only complexity is the set of lines like
<pre>
       struct symtag *lookup( );
</pre>
  This  brings  us  to an area that we will treat only  hurriedly;   the
  question of function  types.&#160;<tt> </tt>So  far,  all  of  our  functions  have
  returned integers (or characters, which are  much the  same).&#160;<tt> </tt>What
  do we do when the function returns something else, like a pointer to a
  structure?&#160;<tt> </tt>The  rule  is that any  function  that  doesn't return an
  <code>int</code> has to say explicitly what it does return.&#160;<tt> </tt>The
  type  information
  goes  before  the   function   name   (which can make the name hard to
  see).
<p>
  Examples:
<pre>
       char f(a)
          int a; {
               ...
       }

       int *g( ) { ... }

       struct symtag *lookup(s) char *s; { ... }
</pre>
  The  function  <code>f</code>  returns  a  character,  <code>g</code>
  returns a  pointer  to an
  integer,  and <code>lookup</code> returns a pointer to a structure
  that looks  like
  <code>symtag</code>.&#160;<tt> </tt>And if we're going to use one
  of  these functions,  we have
  to make a declaration where we use it, as we did in <code>main</code>
  above.
<p>
       Notice the parallelism between the declarations
<pre>
               struct symtag *lookup( );
               struct symtag *psym;
</pre>
  In effect,  this says that <code>lookup( )</code> and <code>psym</code>
  are  both  used the same
  way - as a pointer to a structure -- even though one is a  variable  and
  the other is a function.
<p>
<h2>
      21.&#160;<tt> </tt><a name="initialization">Initialization</a> of Variables
</h2>
       An  external  variable  may  be  initialized  at compile time by
  following its name with an initializing value when it is defined.&#160;<tt> </tt>The
  initializing  value  has  to  be   something   whose value is known at
  compile time, like a constant.
<pre>
       int     x       0;      /* &quot;0&quot; could be any constant */
       int     a       'a';
       char    flag    0177;
       int     *p      &amp;y[1];  /* p now points to y[1] */
</pre>
  An external array can be initialized by following  its   name  with  a
  list of initializations enclosed in braces:
<pre>
       int     x[4]    {0,1,2,3};  /* makes x[i] = i */
       int     y[ ]    {0,1,2,3};  /* makes y big enough for 4 values */
       char    *msg    &quot;syntax error\n&quot;;   /* braces unnecessary here */
       char *keyword[ ]{
               &quot;if&quot;,
               &quot;else&quot;,
               &quot;for&quot;,
               &quot;while&quot;,
               &quot;break&quot;,
               &quot;continue&quot;,
               0
       };
</pre>
  This last one is very useful -- it makes keyword an array  of  pointers
  to  character  strings,  with a zero at the end so we can identify the
  last element easily.&#160;<tt> </tt>A simple lookup  routine   could   scan   this
  until  it either  finds a match or encounters a zero keyword pointer:
<pre>
   lookup(str)             /* search for str in keyword[ ] */
      char *str; {
           int i,j,r;
           for( i=0; keyword[i] != 0; i++) {
                   for( j=0; (r=keyword[i][j]) == str[j] &amp;&amp; r != '\0'; j++ );
                   if( r == str[j] )
                           return(i);
           }
           return(-1);
   }
</pre>
<p>
       Sorry  --  neither  local  variables  nor  structures can    be
  initialized.
<p>
<p>
<h2>
            22.&#160;<tt> </tt><a name="scope">Scope Rules: Who Knows About What</a>
</h2>
       A  complete  C  program  need  not be compiled all at  once;  the
  source text of  the  program  may  be  kept  in  several  files,  and
  previously  compiled routines  may  be  loaded   from libraries.&#160;<tt> </tt>How
  do we arrange that data gets passed from one routine to  another?&#160;<tt> </tt>We
  have  already  seen how to  use function  arguments  and  values,   so
  let us talk about external data.&#160;<tt> </tt>Warning: the words  declaration  and
  definition   are  used precisely in this section; don't treat them as
  the same thing.
<p>
       A major shortcut exists for making extern declarations.&#160;<tt> </tt>If the
  definition  of a variable appears <em>before</em> its use in some function,
  no extern declaration is needed within  the function.&#160;<tt> </tt>Thus, if a file
  contains
<pre>
       f1( ) { ... }

       int foo;

       f2( ) { ... foo = 1; ... }

       f3( ) { ... if ( foo ) ... }
</pre>
  no declaration of <code>foo</code> is needed  in  either  <code>f2</code> 
  or  or  <code>f3</code>,  because
  the external definition of <code>foo</code> appears before them.&#160;<tt> </tt>
  But if <code>f1</code> wants to
  use <code>foo</code>, it has to contain  the  declaration
<pre>
       f1( ) {
               extern int foo;
               ...
       }
</pre>
       This is true  also  of  any   function  that  exists  on  another
  file;  if  it  wants  <code>foo</code> it has to use an extern declaration
  for  it.&#160;<tt> </tt>
  (If somewhere there  is  an  extern declaration  for something,  there
  must also eventually be an external definition of it, or you'll get an
  ``undefined symbol'' message.)
<p>
       There are some  hidden  pitfalls  in  external  declarations  and
  definitions if you use multiple source files.&#160;<tt> </tt>To avoid them, first,
  define and initialize  each   external   variable  only  once  in  the
  entire set of files:
<pre>
       int     foo     0;
</pre>
  You can get away with multiple external definitions on UNIX,  but  not
  on GCOS, so don't ask for trouble.&#160;<tt> </tt>Multiple  initializations  are
  illegal  everywhere.&#160;<tt> </tt>Second,  at  the   beginning   of any file that
  contains functions needing a variable  whose  definition  is  in  some
  other file,  put  in  an extern declaration, outside of any function:
<pre>
       extern  int     foo;

       f1( ) { ... }
          <i>etc.</i>
</pre>
<p>
       The <a href="#include">#include compiler control line</a>,
       to  be  discussed shortly,
  lets you  make  a  single  copy  of  the external declarations  for  a
  program  and  then stick them into each  of the source files making up
  the program.
<p>
<p>
<h2>
                          23.&#160;<tt> </tt><a name="define">#define</a>, #include
</h2>
       C provides a very limited macro facility.&#160;<tt> </tt>You can say
<pre>
       #define name            something
</pre>
  and thereafter anywhere ``name'' appears  as  a  token,  ``something''
  will be substituted.&#160;<tt> </tt>This is particularly useful in parametering
  the sizes of arrays:
<pre>
       #define ARRAYSIZE       100
               int     arr[ARRAYSIZE];
                ...
               while( i++ &lt; ARRAYSIZE )...
</pre>
  (now  we  can alter the entire program by  changing  only  the define)
  or in setting up mysterious constants:
<pre>
       #define SET             01
       #define INTERRUPT       02      /* interrupt bit */
       #define ENABLED 04
        ...
       if( x &amp; (SET | INTERRUPT | ENABLED) ) ...
</pre>
  Now we have meaningful  words  instead  of  mysterious constants.&#160;<tt> </tt>
  (The  mysterious   operators `&amp;' (AND) and `|' (OR) will be covered in
  the  <a href="#bit">next section</a>.)&#160;<tt> </tt>
  It's  an  excellent practice  to  write  programs without any
  literal constants except in #define statements.
<p>
       There  are  several  warnings  about  #define.&#160;<tt> </tt>First, there's
  no semicolon at the end of a #define;  all the text from the  name  to
  the  end  of  the  line  (except  for  comments) is  taken  to  be the
  ``something''.&#160;<tt> </tt>When it's put into the text, blanks are placed around
  it.&#160;<tt> </tt>Good  style typically makes the name in the #define upper case;
  this makes parameters more visible.&#160;<tt> </tt>Definitions affect  things  only
  after they occur, and only within the file in which they occur.&#160;<tt> </tt>
  Defines can't be nested.&#160;<tt> </tt>Last, if there is a #define in a file,
  then the  first  character  of the file <em>must</em> be a `#',  to signal the
  preprocessor that definitions exist.
<p>
       <a name="include">The other control word</a> known  to  C
       is  #include.&#160;<tt> </tt>To include one
  file in your source at compilation time, say
<pre>
       #include &quot;filename&quot;
</pre>
  This is useful for putting a lot of heavily used data definitions  and
  #define statements at the beginning of a file to be compiled.&#160;<tt> </tt>
  As with
  #define,  the  first  line  of  a file containing  a  #include  has to
  begin with a `#'.&#160;<tt> </tt>And #include can't be nested -- an included
  file can't contain  another #include.
<p>
<h2>
                            24.&#160;<tt> </tt><a name="bit">Bit</a> Operators
</h2>
       C has several  operators  for  logical  bit-operations.
  For example,
<pre>
       x = x &amp; 0177;
</pre>
  forms the bit-wise AND of <code>x</code> and 0177, effectively
  retaining only the
  last seven bits of <code>x</code>.&#160;<tt> </tt>Other operators are
<pre>
       |       <i>inclusive OR</i>
       ^       <i>(circumflex) exclusive OR</i>
       ~       <i>(tilde) 1's complement</i>
       !       <i>logical NOT</i>
       &lt;&lt;      <i>left shift (as in x&lt;&lt;2)</i>
       &gt;&gt;      <i>right shift     (arithmetic on PDP-11;  logical on H6070,
  IBM360)</i>
</pre>
<p>
<h2>25.&#160;<tt> </tt><a name="assignment">Assignment</a> Operators</h2>
       An unusual feature of C is that the normal binary operators
 like `+',  `-',   etc.&#160;<tt> </tt>can be combined with the assignment operator
  `=' to form new  assignment  operators.&#160;<tt> </tt>For example,
<pre>
       x =- 10;
</pre>
  uses the assignment operator `=-' to decrement <code>x</code> by 10, and
<pre>
       x =&amp; 0177
</pre>
  forms the AND of <code>x</code> and  0177.&#160;<tt> </tt>
  This convention is a useful
  notational  shortcut, particularly if <code>x</code> is a complicated
  expression.&#160;<tt> </tt>The classic example is summing an array:
<pre>
       for( sum=i=0; i&lt;n; i++ )
               sum =+ array[i];
</pre>
  But the  spaces  around  the  operator  are  critical!&#160;<tt> </tt>For
<pre>
       x = -10;
</pre>
  sets x to -10, while
<pre>
       x =- 10;
</pre>
  subtracts 10 from x.&#160;<tt> </tt>When no space is present,
<pre>
       x=-10;
</pre>
  also  decreases  x  by  10.&#160;<tt> </tt>This   is   quite  contrary  to   the
  experience of most programmers.&#160;<tt> </tt>In particular, watch out for things
  like
<pre>
       c=*s++;
       y=&amp;x[0];
</pre>
  both of which are almost certainly not what you wanted.&#160;<tt> </tt>Newer
  versions  of  various compilers are courteous enough to warn you about
  the ambiguity.
<p>
       Because  all  other  operators  in  an  expression  are evaluated
  before  the  assignment  operator,  the  order of evaluation should be
  watched carefully:
<pre>
       x = x&lt;&lt;y | z;
</pre>
  means ``shift x left y places, then OR with z, and store  in x.'' But
<pre>
       x =&lt;&lt; y | z;
</pre>
  means ``shift x left by y|z places'', which is  rather  different.
<p>
<h2>
                            26.&#160;<tt> </tt><a name="floating">Floating</a> Point
</h2>
       We've skipped over  floating  point  so  far,  and  the treatment
  here will be hasty.&#160;<tt> </tt>C has single and double precision numbers (where
  the precision depends on  the  machine at hand).&#160;<tt> </tt>For example,
<pre>
               double sum;
               float avg, y[10];
               sum = 0.0;
               for( i=0; i&lt;n; i++ )
                       sum =+ y[i];
               avg = sum/n;
</pre>
  forms the sum and average of the array y.
<p>
       All floating arithmetic is done  in  double   precision.&#160;<tt> </tt>Mixed
  mode  arithmetic is legal;  if an arithmetic operator in an expression
  has both operands <code>int</code> or <code>char</code>, the  arithmetic
  done  is  integer,  but
  if one operand is <code>int</code> or <code>char</code> and the
  other is <code>float</code> or <code>double</code>,  both
  operands  are converted  to <code>double</code>.&#160;<tt> </tt>Thus if <code>i</code> and <code>j</code> are <code>int</code> and <code>x</code> is
  <code>float</code>,
<pre>
       (x+i)/j         <i>converts </i>i<i> and </i>j<i> to </i>float
       x + i/j         <i>does </i>i/j<i> integer, then converts</i>
</pre>
  Type conversion may be made by assignment; for instance,
<pre>
               int m, n;
               float x, y;
               m = x;
               y = n;
</pre>
  converts <code>x</code> to integer (truncating toward  zero),   and 
  <code>n</code>  to floating point.
<p>
       Floating constants are just like those   in   Fortran   or  PL/I,
  except that the exponent letter is `e' instead of `E'.&#160;<tt> </tt>Thus:
<pre>
               pi = 3.14159;
               large = 1.23456789e10;
</pre>
       <code>printf</code> will format floating point numbers: ``%w.df'' in the
  format  string  will  print  the  corresponding  variable in a field w
  digits wide, with d decimal places.&#160;<tt> </tt>
  An e instead of an f will produce
  exponential notation.
<p>
<p>
<h2>
          27.&#160;<tt> </tt>Horrors! <a name="goto">goto's</a> and labels
</h2>
       C  has  a goto statement and labels,  so  you  can  branch about
  the way you  used  to.&#160;<tt> </tt>But most of the time goto's  aren't
  needed.&#160;<tt> </tt>(How  many  have we used up  to  this  point?)&#160;<tt> </tt>
  The  code  can  almost
  always  be more clearly expressed by for/while, if/else,  and compound
  statements.
<p>
       One  use  of  goto's  with some legitimacy is in a  program which
  contains a long loop, where a <code>while(1)</code> would
  be too extended.&#160;<tt> </tt>
  Then you might write
<pre>
          mainloop:
               ...
               goto mainloop;
</pre>
  Another use is to implement a <code>break</code> out of more than one level
  of <code>for</code>  or  <code>while</code>.&#160;<tt> </tt>goto's can only
  branch to  labels  within  the  same function.
<p>
<p>
<h2>
                28.&#160;<tt> </tt><a name="acknowledgement">Acknowledgements</a>
</h2>
       I  am indebted to a veritable host of readers  who  made valuable
  criticisms  on  several  drafts  of  this  tutorial.&#160;<tt> </tt>They ranged  in
  experience  from   complete  beginners  through several  implementors
  of  C compilers  to  the  C language designer  himself.&#160;<tt> </tt>
  Needless  to say,  this  is  a   wide   enough  spectrum  of opinion that
  no one is satisfied (including me); comments and suggestions are still 
  welcome, so  that  some future version might be improved.
<p>
<hr>
<p>
<h2>References</h2>
<p>
       C is an extension of B, which was  designed  by  D.  M. Ritchie
  and   K.   L.   Thompson  <a href="#lit-4" name="source-4">[4]</a>.
  The  C  language  design  and   UNIX implementation are the work of
  D. M. Ritchie.&#160;<tt> </tt>
  The GCOS version  was begun  by A. Snyder and B. A. Barres, and completed
  by S.  C.  Johnson and M. E. Lesk.&#160;<tt> </tt>
  The IBM version is primarily  due  to T. G. Peterson, with the assistance
  of M. E. Lesk.
<p>
<dl compact><dt><a name="lit-1" href="#source-1">[1]</a><dd>D. M. Ritchie, C Reference Manual.&#160;<tt> </tt>Bell  Labs,  Jan. 1974.
<p>
<dt><a name="lit-2" href="#source-2">[2]</a><dd>  M.  E.  Lesk &amp; B.  A.  Barres, The  GCOS  C  Library. Bell Labs,
  Jan. 1974.
<p>
<dt><a name="lit-3" href="#source-3">[3]</a><dd>  D.  M.   Ritchie   &amp;   K.   Thompson,  UNIX Programmer's Manual.
  5th Edition, Bell Labs, 1974.
<p>
<dt><a name="lit-4" href="#source-4">[4]</a><dd>  S.  C. Johnson &amp; B.  W.  Kernighan,  The Programming Language B.
  Computer Science  Technical  Report  8, Bell  Labs, 1972.
</dl>
</body>
</html>
